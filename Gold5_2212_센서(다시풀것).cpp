#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/*
	한국도로공사는 고속도로 위에 N개의 센서를 설치하였다. 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

	각 집중국은 센서의 수신 가능 영역을 조절
	집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다.

	N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며,
	집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

	편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자.
	따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오.

	단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.


// 정보
	수신 가능 영역의 범위는 지름이나 반지름의 개념이 아닌 "구간"의 개념.
	따라서 주어진 예제 1번인
	6
	2
	1 6 9 3 6 7
	의 경우, 정답이 5인데, 그 이유는 구간 (1,3)에 집중국 하나, (6,9)에 하나 해서 각 영역의 길이는 2, 3 더해서 5.


// 입력
	첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다.
	셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.




// 출력
	첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.

*/

int main()
{
	int N = 0;
	int K = 0;
	vector<int> sensorPoint;
	vector<int> sensorDist;

	// 센서 개수와 집중국 개수 입력 받기
	cin >> N >> K;

	if (N <= K)
	{
		cout << "0" << '\n';
		return 0;
	}
	// 센서 각 위치 입력 받기
	for (int i = 0; i < N; ++i)
	{
		int temp = 0;
		cin >> temp;
		sensorPoint.push_back(temp);
	}

	// 센서 위치 정렬
	sort(sensorPoint.begin(), sensorPoint.end());

	// 센서 간 거리 계산
	for (int i = 1; i < N; ++i)
		sensorDist.push_back(sensorPoint[i] - sensorPoint[i - 1]);

	// 정렬
	sort(sensorDist.begin(), sensorDist.end());


	/*
	
	6
	5
	1 3 6 6 7 9 ( 정렬 후 )

	이 있다고 치면

	센서 위치 :	1	3	6	6	7	9
	센서간 거리 :	  2	  3	  0	  1	  2

	이 될테고, 여기서 K개의 집중국을 뽑아낸다고 하면 K-1개의 숫자를 기준으로 갈라야함.

	ex) K == 2
	센서 위치 :	1	3	6	6	7	9
	센서간 거리 :	  2	 "3"  0   1	  2
	3을 기준으로 2개가 나뉨. (1,3) , (6,9)

	ex) K == 3
	센서 위치 :	1	3	6	6	7	9
	센서간 거리 :	 "2" "3"  0   1	  2
	3과 2를 기준으로 3개가 나뉨. (1,1) , (3,3), (6,9)

	ex) K == 4
	센서 위치 :	1	3	6	6	7	9
	센서간 거리 :	 "2" "3"  0   1	 "2"
	3, 2, 2를 기준으로 4개가 나뉨. (1,1) , (3,3), (6,7), (9,9)


	*/

	int minResult = 0;
	for (int i = 0; i <= N-1 - K; ++i)
		minResult += sensorDist[i];

	cout << minResult;



	return 0;
}


/*

반례 :
6
5
1 3 6 6 7 9

(1,1)
(3,3)
(6,6)
(7,7)
(9,9)

답 : 0
======================================
6
4
1 3 6 6 7 9

(1,1)
(3,3)
(6,7)
(9,9)

답 : 1
======================================
7
5
1 2 3 6 6 7 9

(1,2)
(3,3)
(6,6)
(7,7)
(9,9)

답 : 1
======================================
7
4
1 2 3 6 6 7 9

(1,3)
(6,6)
(7,7)
(9,9)

답 : 2







*/